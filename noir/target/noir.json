{"noir_version":"1.0.0-beta.6+e796dfd67726cbc28eb9991782533b211025928d","hash":"11768207330701452097","abi":{"parameters":[{"name":"coupon","type":{"kind":"field"},"visibility":"public"},{"name":"user","type":{"kind":"field"},"visibility":"public"},{"name":"once","type":{"kind":"field"},"visibility":"public"},{"name":"fee","type":{"kind":"field"},"visibility":"public"},{"name":"secret0","type":{"kind":"field"},"visibility":"private"},{"name":"secret1","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{"3887441833480942226":{"error_kind":"string","string":"Incorrect secret"},"14613855438306196385":{"error_kind":"string","string":"Incorrect coupon"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","file_map":{"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"19":{"source":"// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H>\nwhere\n    H: Hasher,\n{\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"22":{"source":"pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time.\n// The message can be a string, a format string, or any value, as long as it is known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<T>(predicate: bool, message: T) {}\n\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_add(y)\")]\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_sub(y)\")]\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_mul(y)\")]\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    use super::ops::arith::WrappingMul;\n\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n\n    #[test]\n    fn test_wrapping_mul() {\n        let zero: u128 = 0;\n        let one: u128 = 1;\n        let two_pow_64: u128 = 0x10000000000000000;\n        let u128_max: u128 = 0xffffffffffffffffffffffffffffffff;\n\n        // 1*0==0\n        assert_eq(zero, zero.wrapping_mul(one));\n\n        // 0*1==0\n        assert_eq(zero, one.wrapping_mul(zero));\n\n        // 1*1==1\n        assert_eq(one, one.wrapping_mul(one));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(zero, zero.wrapping_mul(two_pow_64));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(zero, two_pow_64.wrapping_mul(zero));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(two_pow_64, two_pow_64.wrapping_mul(one));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(two_pow_64, one.wrapping_mul(two_pow_64));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(zero, two_pow_64.wrapping_mul(two_pow_64));\n        // -1 * -1 == 1\n        assert_eq(one, u128_max.wrapping_mul(u128_max));\n    }\n}\n","path":"std/lib.nr"},"50":{"source":"use dep::std::{self};\n\nfn main(\n    coupon: pub Field,\n    user: pub Field,\n    once: pub Field,\n    fee: pub Field,\n    secret0: Field,\n    secret1: Field,\n) {\n    let hash_secret: Field = std::hash::hash_to_field([secret0, secret1]);\n    let expected_secret: Field = 0x29cc38a38450970d467f7e60428805a67bd687eff454e0cf8ef773ae2c210fe7;\n    assert(hash_secret == expected_secret, \"Incorrect secret\");\n\n    let hash_data: Field = std::hash::hash_to_field([user, once, fee, expected_secret]);\n    println(hash_data);\n    assert(hash_data == coupon, \"Incorrect coupon\");\n}\n\n#[test]\nfn test_main() {\n    let secret0= 1337;\n    let secret1: Field = 42;\n    let expected_secret: Field = std::hash::hash_to_field([1337, 42]);\n\n    let user: Field = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    let once: Field = 1;\n    // 0,1% fees\n    let fee: Field = 100;\n\n    let coupon: Field = std::hash::hash_to_field([user, once, fee, expected_secret]);\n\n    main(coupon, user, once, fee, secret0, secret1);\n\n}\n\n#[test(should_fail_with = \"Incorrect secret\")]\nfn test_secret() {\n    let secret0= 1337;\n    let secret1: Field = 42;\n    let expected_secret: Field = std::hash::hash_to_field([secret0, secret1]);\n\n    let user: Field = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    let once: Field = 1;\n    // 0,1% fees\n    let fee: Field = 100;\n\n    let coupon: Field = std::hash::hash_to_field([user, once, fee, expected_secret]);\n\n    main(coupon, user, once, fee, 12, secret1);\n\n}\n\n\n#[test(should_fail_with = \"Incorrect coupon\")]\nfn test_coupon() {\n    let secret0= 1337;\n    let secret1: Field = 42;\n    let expected_secret: Field = std::hash::hash_to_field([13377, 42]);\n\n    let user: Field = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    let once: Field = 1;\n    // 0,1% fees\n    let fee: Field = 100;\n\n    let coupon: Field = std::hash::hash_to_field([user, 0, fee, expected_secret]);\n\n    main(coupon, user, once, fee, secret0, secret1);\n\n}","path":"/Users/eddy/Projects/amm-proof/noir/src/main.nr"}},"names":["main"],"brillig_names":["print_unconstrained","directive_to_radix","directive_invert","directive_integer_quotient"]}